ECircuit. circuit ::= circuit id ":" JinfoK? "(" [module] ")" ;
EModule. module ::= module id ":" JinfoK? "(" [port] stmt ")"
    | extmodule id ":" JinfoK? "(" [port] ")" ;
EPort. port ::= dir id ":" type JinfoK? ;
EDir. dir ::= input | output ;
EType. type ::= UIntJ<int>K?
    | SIntJ<int>K?
    | FixedJ<int>K?J<<int>>K?
    | Clock
    | AnalogJ<int>K?
    | "{" [field] "}"
    | type "[" int "]" ;
EField. field ::= JflipK? id ":" type ;
EStmt. stmt ::= wire id ":" type JinfoK?
    | reg id ":" type exp J "(" with ":" "{" reset => "(" exp, exp ")" "}" ")" K? JinfoK?
    | mem id ":" JinfoK? "(" 
        data-type "=>" type
        depth "=>" int
        read-latency "=>" int
        write-latency "=>" int
        read-under-write "=>" ruw
        [reader "=>" id]
        [writer "=>" id]
        [readwriter "=>" id] ")"
    | inst id of id JinfoK?
    | node id "=" exp JinfoK?
    | exp "<=" exp JinfoK?
    | exp "<-" exp JinfoK?
    | exp is invalid JinfoK?
    | attach "(" [exp] ")" JinfoK?
    | when exp ":" JinfoK? stmt Jelse ":" stmtK?
    | stop "(" exp, exp, int ")" J ":" idK? JinfoK?
    | printf "(" exp, exp, string, [exp] ")" J ":" idK? JinfoK?
    | skip JinfoK?
    | "(" [stmt] ")" ;
ERuw. ruw ::= old | new | undefined ;
EInfo. info ::= "@" "[" string "]" ;
EExp. exp ::= UIntJ<int>K? "(" int ")"
    | UIntJ<int>K? "(" string ")"
    | SIntJ<int>K? "(" int ")"
    | SIntJ<int>K? "(" string ")"
    | id
    | exp.id
    | exp "[" int "]"
    | exp "[" exp "]"
    | mux "(" exp, exp, exp ")"
    | validif "(" exp, exp ")"
    | primop "(" [exp] "," [int] ")" ;
EPrimop. primop ::= add
    | sub
    | mul
    | div
    | mod
    | lt
    | leq
    | gt
    | geq
    | eq
    | neq
    | pad
    | asUInt
    | asSInt
    | asClock
    | shl
    | shr
    | dshl
    | dshr
    | cvt
    | neg
    | not
    | and
    | or
    | xor
    | andr
    | orr
    | xorr
    | cat
    | bits
    | head
    | tail ;
